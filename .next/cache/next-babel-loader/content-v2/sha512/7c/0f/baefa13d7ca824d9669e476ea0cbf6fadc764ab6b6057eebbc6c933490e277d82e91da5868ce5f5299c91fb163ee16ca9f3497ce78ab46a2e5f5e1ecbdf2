{"ast":null,"code":"'use strict';\n\nconst authorInDictionary = require('./matchAuthorAndDictionary.js');\n\nconst dictionaryObject = require('./extractDictionary.js');\n\nfunction formatWord(word) {\n  let formattedWord = word.replace(/[\\W\\d_]+/g, '').toUpperCase();\n  return formattedWord;\n}\n\nfunction randomWordIndex(arr) {\n  let index = Math.floor(Math.random() * arr.length);\n  return index;\n}\n\nfunction checkStress(word) {\n  if (!word) return null;\n  let wordSyllables = dictionaryObject[formatWord(word)]; // console.log(wordSyllables)\n  // if (wordSyllables === undefined) return null;\n\n  let wordStress = wordSyllables.match(/[0-9]+/ig).join(''); // \"cooler\", \"unbridled\", \"accompaniment\", \"alberto\" returned null\n  // console.log(wordStress)\n\n  return wordStress;\n}\n\nfunction getFirstWord(input) {\n  if (input) {\n    // remove any non letter\n    let word = input.replace(/[\\W\\d_]+/g, ''); //future improvements: add more proper nouns\n\n    if (word !== 'I' && word !== 'God') {\n      word = word.toLowerCase();\n    }\n\n    if (authorInDictionary.hasOwnProperty(word)) {\n      return word[0].toUpperCase() + word.slice(1);\n    }\n  } // if word is not viable or in authorInDictionary\n\n\n  return 'Divine';\n}\n\nfunction getRandomWord() {\n  // length of authorInDictionary\n  let count = 0;\n\n  for (let key in authorInDictionary) {\n    count++;\n  } // random 'index' of authorInDictionary\n\n\n  let index = Math.floor(Math.random() * count);\n\n  for (let newKey in authorInDictionary) {\n    if (index > 0) index--;else return newKey;\n  }\n}\n\nfunction getLastWord(line) {\n  let lastSpace = 0;\n  let penultimateSpace = 0;\n  let endIndex = 0;\n\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] === ' ') {\n      penultimateSpace = lastSpace;\n      lastSpace = i;\n    } else if (line[i] === '(') {\n      endIndex = i;\n      return line.slice(penultimateSpace + 1, endIndex - 1);\n    }\n  }\n}\n\nfunction getNextWord(currentWord, counter) {\n  if (counter === undefined) {\n    counter = 0;\n  }\n\n  let stressOfCurrent = checkStress(currentWord);\n  let newStress;\n  let arrayOfNext = authorInDictionary[currentWord];\n  let possibleNext;\n  let possibleStress; //error handling\n\n  if (arrayOfNext) {\n    possibleNext = arrayOfNext[randomWordIndex(arrayOfNext)];\n    possibleStress = checkStress(possibleNext);\n    console.log(currentWord, stressOfCurrent, possibleNext, possibleStress);\n  } else {\n    console.log(currentWord, \"GOT RANDOM BECAUSE ARRAY OF NEXT DOES NOT EXIST\");\n    return getNextWord(getRandomWord());\n  }\n\n  if (stressOfCurrent === null) {\n    console.log(currentWord, \"GOT RANDOM BECAUSE CURRENT STRESS WAS NULL\");\n    return getNextWord(getRandomWord());\n  } else if (counter > 10) {\n    if (possibleStress === null) {\n      console.log(possibleNext, possibleStress, \"GOT RANDOM BECAUSE POSSIBLE STRESS WAS NULL AND COUNTER WAS OVER 10\");\n      return getNextWord(getRandomWord());\n    } else {\n      console.log(possibleNext, \"COUNTER WAS OVER TEN\");\n      return possibleNext;\n    }\n  } else if (checkStress(possibleNext) === null) {\n    counter++;\n    return getNextWord(currentWord, counter);\n  } //compare stresses\n\n\n  if (Number.parseInt(stressOfCurrent.slice(-1), 10) === 0) {\n    newStress = 1;\n  } else {\n    newStress = 0;\n  }\n\n  console.log(\"end of current and new \", stressOfCurrent.slice(-1), newStress); // use a 2 stress as a 1 stress\n  // future improvements: include logic to utilize 1 < 2 for stress\n  //  will need to look at backwards stresses, not just the preceding one\n\n  if (possibleStress[0] === 2) possibleStress[0] = 1;\n  console.log(newStress, possibleStress[0], Number.parseInt(possibleStress[0], 10) === newStress);\n\n  if (Number.parseInt(possibleStress[0], [10]) === newStress) {\n    return possibleNext;\n  } else {\n    counter++;\n    return getNextWord(currentWord, counter);\n  }\n}\n\nfunction getLine(currentWord, start) {\n  let currentLine = '';\n  let currentLineStress = '';\n\n  if (start === true) {\n    currentWord = getFirstWord(currentWord);\n    currentLine = currentWord;\n    currentLineStress = checkStress(currentWord);\n  }\n\n  while (currentLineStress.length < 10) {\n    currentWord = getNextWord(currentWord.toLowerCase());\n    currentLine += ' ' + currentWord;\n    currentLineStress += checkStress(currentWord);\n  }\n\n  return currentLine + ' (' + currentLineStress + ')<br>';\n}\n\nfunction getPoem(startWord) {\n  let poemLines = '';\n  let numLines = 0;\n  let currentWord;\n  let line;\n\n  while (numLines < 10) {\n    if (numLines === 0) {\n      currentWord = startWord;\n      line = getLine(currentWord, true);\n    } else {\n      line = getLine(currentWord, false);\n    }\n\n    numLines++;\n    poemLines += line;\n    currentWord = getLastWord(line);\n  }\n\n  return poemLines;\n}\n\nmodule.exports = getPoem; // authorInDictionary[\"my\"];","map":{"version":3,"sources":["/Users/hannahcain/iambic/poemGenerator.js"],"names":["authorInDictionary","require","dictionaryObject","formatWord","word","formattedWord","replace","toUpperCase","randomWordIndex","arr","index","Math","floor","random","length","checkStress","wordSyllables","wordStress","match","join","getFirstWord","input","toLowerCase","hasOwnProperty","slice","getRandomWord","count","key","newKey","getLastWord","line","lastSpace","penultimateSpace","endIndex","i","getNextWord","currentWord","counter","undefined","stressOfCurrent","newStress","arrayOfNext","possibleNext","possibleStress","console","log","Number","parseInt","getLine","start","currentLine","currentLineStress","getPoem","startWord","poemLines","numLines","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst authorInDictionary = require('./matchAuthorAndDictionary.js');\nconst dictionaryObject = require('./extractDictionary.js');\n\n\nfunction formatWord (word) {\n  let formattedWord = word.replace(/[\\W\\d_]+/g, '').toUpperCase();\n  return formattedWord;\n}\n\nfunction randomWordIndex (arr) {\n  let index = Math.floor(Math.random() * arr.length);\n  return index;\n}\n\nfunction checkStress (word) {\n  if (!word) return null;\n  let wordSyllables = dictionaryObject[formatWord(word)];\n  // console.log(wordSyllables)\n  // if (wordSyllables === undefined) return null;\n  let wordStress = wordSyllables.match(/[0-9]+/ig).join('');\n  // \"cooler\", \"unbridled\", \"accompaniment\", \"alberto\" returned null\n  // console.log(wordStress)\n  return wordStress;\n}\n\nfunction getFirstWord (input) {\n  if (input) {\n    // remove any non letter\n    let word = input.replace(/[\\W\\d_]+/g, '');\n\n    //future improvements: add more proper nouns\n    if (word !== 'I' && word !== 'God' ) {\n      word = word.toLowerCase();\n    }\n\n    if (authorInDictionary.hasOwnProperty(word)) {\n      return word[0].toUpperCase() + word.slice(1);\n    }\n  }\n\n  // if word is not viable or in authorInDictionary\n  return 'Divine';\n}\n\nfunction getRandomWord () {\n  // length of authorInDictionary\n  let count = 0;\n  for (let key in authorInDictionary) {\n    count++;\n  }\n  // random 'index' of authorInDictionary\n  let index = Math.floor(Math.random() * count);\n  for (let newKey in authorInDictionary) {\n    if (index > 0) index--;\n    else return newKey;\n  }\n}\n\nfunction getLastWord (line) {\n  let lastSpace = 0;\n  let penultimateSpace = 0;\n  let endIndex = 0;\n    for (let i = 0; i < line.length; i++) {\n      if (line[i] === ' ') {\n        penultimateSpace = lastSpace;\n          lastSpace = i;\n        } else if (line[i] === '(') {\n          endIndex = i;\n          return (line.slice(penultimateSpace + 1, endIndex - 1));\n        }\n    }\n}\n\nfunction getNextWord(currentWord, counter) {\n\n  if (counter === undefined) { counter = 0 }\n  let stressOfCurrent = checkStress(currentWord);\n  let newStress;\n  let arrayOfNext = authorInDictionary[currentWord];\n  let possibleNext;\n  let possibleStress;\n\n  //error handling\n  if (arrayOfNext) {\n    possibleNext = arrayOfNext[randomWordIndex(arrayOfNext)];\n    possibleStress = checkStress(possibleNext);\n    console.log(currentWord, stressOfCurrent, possibleNext, possibleStress)\n  } \n  else {\n    console.log( currentWord, \"GOT RANDOM BECAUSE ARRAY OF NEXT DOES NOT EXIST\")\n    return getNextWord(getRandomWord());\n  }\n\n  if (stressOfCurrent === null) {\n    console.log( currentWord, \"GOT RANDOM BECAUSE CURRENT STRESS WAS NULL\")\n    return getNextWord(getRandomWord());\n\n  } else if (counter > 10) {\n    if (possibleStress === null) {\n      console.log( possibleNext, possibleStress, \"GOT RANDOM BECAUSE POSSIBLE STRESS WAS NULL AND COUNTER WAS OVER 10\")\n      return getNextWord(getRandomWord());\n    } else {\n      console.log(possibleNext, \"COUNTER WAS OVER TEN\")\n      return possibleNext;\n    }\n\n  } else if (checkStress(possibleNext) === null) {\n    counter++;\n    return getNextWord(currentWord, counter);\n  }\n\n  //compare stresses\n  if ( Number.parseInt(stressOfCurrent.slice(-1), 10) === 0) { newStress = 1; }\n  else { newStress = 0; }\n  console.log(\"end of current and new \", stressOfCurrent.slice(-1), newStress)\n\n  // use a 2 stress as a 1 stress\n  // future improvements: include logic to utilize 1 < 2 for stress\n  //  will need to look at backwards stresses, not just the preceding one\n  if (possibleStress[0] === 2) possibleStress[0] = 1;\n  console.log(newStress, possibleStress[0], Number.parseInt(possibleStress[0], 10) === newStress )\n  if (Number.parseInt(possibleStress[0], [10]) === newStress ) {\n    return possibleNext;\n  } else {\n    counter++;\n    return getNextWord(currentWord, counter);\n  }\n}\n\nfunction getLine(currentWord, start) {\n  let currentLine = '';\n  let currentLineStress = '';\n  if (start === true) {\n    currentWord = getFirstWord(currentWord);\n    currentLine = currentWord;\n    currentLineStress = (checkStress(currentWord));\n  }\n\n  while (currentLineStress.length < 10 ) {\n    currentWord = getNextWord(currentWord.toLowerCase());\n    currentLine += ' ' + currentWord;\n    currentLineStress += (checkStress(currentWord));\n  }\n  return currentLine + ' (' + currentLineStress + ')<br>';\n}\n\nfunction getPoem (startWord) {\n  let poemLines = '';\n  let numLines = 0;\n  let currentWord;\n  let line;\n  while (numLines < 10) {\n\n    if (numLines === 0) {\n      currentWord = startWord;\n      line = getLine(currentWord, true);\n\n    } else {\n      line = getLine(currentWord, false);\n    }\n\n    numLines++;\n    poemLines += line;\n    currentWord = getLastWord(line);\n\n  }\n  return poemLines;\n}\n\nmodule.exports = getPoem;\n\n// authorInDictionary[\"my\"]; \n\n"]},"metadata":{},"sourceType":"script"}